import org.eclipse.paho.client.mqttv3.*;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import javax.net.ssl.KeyManagerFactory;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyStore;
import java.util.Base64;

public class Subscriber {
    public static SSLSocketFactory getSocketFactory(String keystoreFile, String keystorePassword, String truststoreFile, String truststorePassword) throws Exception {
        // Load client keystore (private key + certificate)
        KeyStore clientKeyStore = KeyStore.getInstance("JKS");
        FileInputStream fis = new FileInputStream(keystoreFile);
        clientKeyStore.load(fis, keystorePassword.toCharArray());
        fis.close();

        // Initialize KeyManagerFactory using client keystore
        KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
        kmf.init(clientKeyStore, keystorePassword.toCharArray());

        // Load the truststore (CA certificate)
        KeyStore trustStore = KeyStore.getInstance("JKS");
        fis = new FileInputStream(truststoreFile);
        trustStore.load(fis, truststorePassword.toCharArray());
        fis.close();

        // Initialize truststore
        TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
        tmf.init(trustStore);

        // Initialize SSL
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

        return sslContext.getSocketFactory();
    }
    public static String decrypt(String encryptedData, SecretKey key) throws Exception {
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decodedData = Base64.getDecoder().decode(encryptedData);
        return new String(cipher.doFinal(decodedData));
    }
    public static boolean verifyHMAC(String message, String receivedHmac, String secret) throws Exception {
        Mac mac = Mac.getInstance("HmacSHA256");
        SecretKeySpec secretKey = new SecretKeySpec(secret.getBytes(), "HmacSHA256");
        mac.init(secretKey);
        byte[] computedHmacBytes = mac.doFinal(message.getBytes());
        String computedHmac = Base64.getEncoder().encodeToString(computedHmacBytes);
        return computedHmac.equals(receivedHmac);
    }
    public static SecretKey loadKey(String filePath) throws Exception {
        byte[] keyBytes = Files.readAllBytes(Paths.get(filePath));
        return new SecretKeySpec(keyBytes, "AES");
    }
    public static void main(String[] args) {
        String broker = "ssl://test.mosquitto.org:8883";
        String clientId = "SubscriberClient";
        String topic = "Stefan Topic MQTT";

        // HMAC Secret
        final String SHARED_SECRET = "stefanmqtt";

        try {
            // Key generated by Util class, MUST be the same as the publisher
            SecretKey key = loadKey("NeededItems/shared_key.key");

            // MQTT setup
            MqttClient client = new MqttClient(broker, clientId);
            MqttConnectOptions options = new MqttConnectOptions();
            SSLSocketFactory sslSocketFactory = getSocketFactory("NeededItems/client.jks", "client-password", "NeededItems/client.jks", "client-password");
            options.setSocketFactory(sslSocketFactory);
            client.connect(options);

            // Subscribe to the topic
            client.subscribe(topic);
            client.setCallback(new MqttCallback() {
                @Override
                public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
                    String combinedMessage = new String(mqttMessage.getPayload());

                    // Split the combined message into HMAC and encrypted message
                    String[] parts = combinedMessage.split("\\|", 2);
                    if (parts.length != 2) {
                        System.out.println("Invalid message format. Discarding.");
                        return;
                    }

                    String receivedHmac = parts[0];
                    String encryptedMessage = parts[1];

                    // Verify HMAC
                    if (verifyHMAC(encryptedMessage, receivedHmac, SHARED_SECRET)) {
                        // Decrypt if HMAC is valid
                        String decryptedMessage = decrypt(encryptedMessage, key);
                        System.out.println("Decrypted and authenticated message: " + decryptedMessage);
                    } else {
                        System.out.println("HMAC verification failed. Message discarded.");
                    }
                }
                @Override
                public void connectionLost(Throwable cause) {
                    System.out.println("Connection lost: " + cause.getMessage());
                }
                @Override
                public void deliveryComplete(IMqttDeliveryToken token) {
                }
            });
            System.out.println("Subscriber connected and listening.");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
